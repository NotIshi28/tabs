<html>
  <head>
<title>Totally Accurate Battle Simulator</title>
<style>
  body { 
    font-family: Arial, sans-serif;
    background-color: #1a1a2e;
    color: #e0e0e0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: hidden;
  }
  #game-container {
    flex-grow: 1;
    background-color: #16213e;
    border: 2px solid #0f3460;
    position: relative;
    overflow: hidden;
    cursor: crosshair;
  }
  #controls-panel {
    background-color: #0f3460;
    padding: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .control-group {
    display: flex;
    align-items: center;
  }
  select, button {
    margin: 0 5px;
    padding: 5px 10px;
    background-color: #1a1a2e;
    color: #e0e0e0;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s;
  }
  button:hover, select:hover { background-color: #e94560; }
  #speed-control {
    display: flex;
    align-items: center;
  }
  #speed-slider {
    width: 100px;
  }
  .unit {
    width: 40px;
    height: 40px;
    position: absolute;
    transition: all 0.2s linear;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .team-indicator {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    position: absolute;
    opacity: 0.5;
  }
  .blue .team-indicator { background-color: #3498db; }
  .red .team-indicator { background-color: #e74c3c; }
  .purple .team-indicator { background-color: #9b59b6; }
  .weapon-icon {
    width: 30px;
    height: 30px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    z-index: 1;
  }
  .warrior .weapon-icon { background-image: none; }
  .warrior .wooden-sword {
    position: absolute;
    width: 6px;
    height: 40px;
    background-color: #8B4513;
    border-radius: 1px;
    transition: all 0.2s linear;
    z-index: 2;
  }
  .warrior .wooden-sword::before {
    content: '';
    position: absolute;
    width: 12px;
    height: 4px;
    background-color: #D2691E;
    top: -4px;
    left: -3px;
    border-radius: 1px;
  }
  .warrior .wooden-sword::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    border-bottom: 10px solid #8B4513;
    bottom: -10px;
    left: 0;
  }
  .warrior.attacking .wooden-sword {
    transform: rotate(90deg);
  }
  .mage .wooden-staff {
    position: absolute;
    width: 4px;
    height: 50px;
    background-color: #8B4513;
    border-radius: 1px;
    transition: all 0.2s linear;
    z-index: 2;
  }
  .mage .wooden-staff::before {
    content: '';
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #9932CC;
    border-radius: 50%;
    top: -8px;
    left: -3px;
    box-shadow: 0 0 5px #9932CC;
  }
  .archer .weapon-icon { background-image: none; }
  .archer .bow {
    position: absolute;
    width: 30px;
    height: 40px;
    border-top: 4px solid #8B4513;
    border-right: 4px solid #8B4513;
    border-bottom: 4px solid #8B4513;
    border-left: none;
    border-radius: 0 100px 100px 0;
    transform: rotate(0deg);
    transition: all 0.2s linear;
    z-index: 2;
  }
  .archer .bow::before {
    content: '';
    position: absolute;
    width: 2px;
    height: 36px;
    background-color: #F4A460;
    left: 0px;
    top: 2px;
  }
  .archer.attacking .bow {
    transform: rotate(-30deg);
  }
  .healer .weapon-icon 
  { 
    background-image: none; 
  }
  .healer .healing-staff {
    position: absolute;
    width: 4px;
    height: 50px;
    background-color: #8B4513;
    border-radius: 1px;
    transition: all 0.2s linear;
    z-index: 2;
  }
  .healer .healing-staff::before {
    content: '';
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: #FF0000;
    border-radius: 50%;
    top: -8px;
    left: -3px;
    box-shadow: 0 0 5px #FF0000;
  }
  .tank .weapon-icon { background-image: none; }
  .tank .iron-shield {
    position: absolute;
    width: 30px;
    height: 40px;
    background-color: #708090;
    border: 2px solid #2F4F4F;
    border-radius: 5px;
    transition: all 0.2s linear;
    z-index: 2;
    left: -15px;
  }
  .tank .iron-sword {
    position: absolute;
    width: 6px;
    height: 30px;
    background-color: #C0C0C0;
    border-radius: 1px;
    transition: all 0.2s linear;
    z-index: 3;
    right: -3px;
  }
  .tank .iron-sword::before {
    content: '';
    position: absolute;
    width: 12px;
    height: 4px;
    background-color: #A9A9A9;
    top: -4px;
    left: -3px;
    border-radius: 1px;
  }
  .tank .iron-sword::after {
    content: '';
    position: absolute;
    width: 0;
    height: 0;
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    border-bottom: 8px solid #C0C0C0;
    bottom: -8px;
    left: 0;
  }
  .tank.attacking .iron-sword {
    transform: rotate(45deg);
  }
  .musketman .weapon-icon { background-image: none; }
  .musketman .musket {
    position: absolute;
    width: 50px;
    height: 10px;
    background-color: #8B4513;
    border-radius: 2px;
    transition: all 0.2s linear;
    z-index: 2;
  }
  .musketman .musket::before {
    content: '';
    position: absolute;
    width: 15px;
    height: 25px;
    background-color: #D2691E;
    bottom: -8px;
    right: 0;
    border-radius: 2px;
  }
  .musketman .musket::after {
    content: '';
    position: absolute;
    width: 10px;
    height: 5px;
    background-color: #A0522D;
    top: 10px;
    left: 5px;
    border-radius: 1px;
  }
  .musketman.attacking .musket {
    transform: rotate(-10deg);
  }
  .projectile {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    position: absolute;
    transition: all 0.5s linear;
  }
  .attack-projectile { background-color: #95a5a6; }
  .mage-projectile { 
    background-color: #3498db;
    box-shadow: 0 0 10px #3498db;
  }
  .heal-projectile { background-color: #e74c3c; }
  .musket-projectile {
    width: 5px;
    height: 5px;
    background-color: #2c3e50;
  }
  .health-bar {
    width: 40px;
    height: 5px;
    background-color: #27ae60;
    position: absolute;
    top: -10px;
    left: 0;
    display: none;
  }
  .unit:hover .health-bar, .show-health-bars .health-bar {
    display: block;
  }
  .unit-label {
    position: absolute;
    bottom: -20px;
    font-size: 10px;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 2px 4px;
    border-radius: 3px;
    white-space: nowrap;
  }
  #stats-panel {
    position: fixed;
    right: 20px;
    top: 50%;
    transform: translateY(-50%);
    background-color: rgba(22, 33, 62, 0.8);
    padding: 10px;
    border-radius: 5px;
    display: none;
  }
  #update-message {
    position: fixed;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #27ae60;
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    display: none;
    animation: fadeOut 3s forwards;
  }
  @keyframes fadeOut {
    0% { opacity: 1; }
    70% { opacity: 1; }
    100% { opacity: 0; }
  }
  .selected {
    outline: 2px solid #e94560;
  }
</style>
</head>
<body>
<div id="game-container"></div>
<div id="controls-panel">
  <div class="control-group">
    <select id="unit-type">
      <option value="warrior">Warrior</option>
      <option value="archer">Archer</option>
      <option value="mage">Mage</option>
      <option value="healer">Healer</option>
      <option value="tank">Tank</option>
      <option value="musketman">Musketman</option>
    </select>
    <select id="team-select">
      <option value="blue">Blue</option>
      <option value="red">Red</option>
      <option value="purple">Purple</option>
    </select>
  </div>
  <div class="control-group">
    <button onclick="togglePlacementMode()">Placement Mode</button>
    <button onclick="toggleDeleteMode()">Delete Mode</button>
    <button onclick="toggleHealthbarMode()">Healthbar Mode</button>
    <button onclick="toggleSelectionMode()">Selection Mode</button>
  </div>
  <div class="control-group">
    <button onclick="applyFormation('line')">Line</button>
    <button onclick="applyFormation('column')">Column</button>
    <button onclick="applyFormation('wedge')">Wedge</button>
    <button onclick="applyFormation('square')">Square</button>
    <button onclick="applyFormation('circle')">Circle</button>
  </div>
  <div class="control-group">
    <button onclick="startBattle()">Start Battle</button>
    <div id="speed-control">
      <label for="speed-slider">Speed:</label>
      <input type="range" id="speed-slider" min="1" max="20" value="10" onchange="updateSpeed()">
    </div>
  </div>
</div>

<div id="stats-panel"></div>
<div id="update-message">Game layout updated</div>

<script>
  const gameContainer = document.getElementById('game-container');
  const units = { blue: [], red: [], purple: [] };
  let battleSpeed = 10;
  let placementMode = true;
  let deleteMode = false;
  let healthbarMode = false;
  let selectionMode = false;
  let selectedUnits = [];
  let battleInterval;
  
  const unitTypes = {
    warrior: { health: 100, damage: 10, speed: 5, range: 30, isRanged: false, type: 'M', weapon: 'Wooden Sword', attackCooldown: 1000 },
    archer: { health: 90, damage: 15, speed: 6, range: 150, isRanged: true, type: 'R', weapon: 'Bow' },
    mage: { health: 60, damage: 20, speed: 4, range: 160, isRanged: true, type: 'R', weapon: 'Wooden Staff' },
    healer: { health: 70, damage: 5, speed: 5, range: 80, healPower: 10, isRanged: true, type: 'S', weapon: 'Healing Staff' },
    tank: { health: 150, damage: 20, speed: 3, range: 40, isRanged: false, type: 'M', weapon: 'Iron Sword', shield: 'Iron Shield', attackCooldown: 1000 },
    musketman: { health: 80, damage: 25, speed: 4, range: 175, isRanged: true, type: 'R', weapon: 'Musket', attackCooldown: 2000 }
  };
  
  function togglePlacementMode() {
    placementMode = !placementMode;
    if (placementMode) {
      deleteMode = false;
      selectionMode = false;
    }
    updateModeDisplay();
  }

  function toggleDeleteMode() {
  deleteMode = !deleteMode;
  if (deleteMode) {
    placementMode = false;
    selectionMode = false;
  }
  updateModeDisplay();
}

function toggleHealthbarMode() {
  healthbarMode = !healthbarMode;
  gameContainer.classList.toggle('show-health-bars', healthbarMode);
  updateModeDisplay();
}

function toggleSelectionMode() {
  selectionMode = !selectionMode;
  if (selectionMode) {
    placementMode = false;
    deleteMode = false;
  } else {
    clearSelection();
  }
  updateModeDisplay();
}

function updateModeDisplay() {
  gameContainer.style.cursor = placementMode ? 'crosshair' : (deleteMode ? 'not-allowed' : 'default');
}

gameContainer.addEventListener('click', function(e) {
  if (placementMode) {
    const rect = gameContainer.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    addUnit(x, y);
""} else if (deleteMode) {
    const clickedUnit = e.target.closest('.unit');
    if (clickedUnit) {
      deleteUnit(clickedUnit);
    }
  } else if (selectionMode) {
    const clickedUnit = e.target.closest('.unit');
    if (clickedUnit) {
      toggleUnitSelection(clickedUnit);
    } else {
      clearSelection();
    }
  }
});

function toggleUnitSelection(unit) {
  if (unit.classList.contains('selected')) {
    unit.classList.remove('selected');
    selectedUnits = selectedUnits.filter(u => u !== unit);
  } else {
    unit.classList.add('selected');
    selectedUnits.push(unit);
  }
}

function clearSelection() {
  selectedUnits.forEach(unit => unit.classList.remove('selected'));
  selectedUnits = [];
}

function addUnit(x, y) {
  const typeSelect = document.getElementById('unit-type');
  const teamSelect = document.getElementById('team-select');
  const type = typeSelect.value;
  const team = teamSelect.value;
  const unit = document.createElement('div');
  unit.className =  `unit ${type} ${team}`;
  unit.innerHTML = `
    <div class="team-indicator"></div>
    <div class="weapon-icon"></div>
    <div class="health-bar"></div>
    <div class="unit-label">${type.charAt(0).toUpperCase() + type.slice(1)} || ${unitTypes[type].type}</div>
    ${type === 'warrior' ? '<div class="wooden-sword"></div>' : ''}
    ${type === 'mage' ? '<div class="wooden-staff"></div>' : ''}
    ${type === 'archer' ? '<div class="bow"></div>' : ''}
    ${type === 'healer' ? '<div class="healing-staff"></div>' : ''}
    ${type === 'tank' ? '<div class="iron-shield"></div><div class="iron-sword"></div>' : ''}
    ${type === 'musketman' ? '<div class="musket"></div>' : ''}
  `;
  unit.style.left = `${x - 20}px`;
  unit.style.top = `${y - 20}px`;
  Object.assign(unit, unitTypes[type]);
  unit.team = team;
  unit.maxHealth = unit.health;
  unit.projectiles = type === 'healer' ? 3 : 2;
  unit.lastHealTime = 0;
  unit.lastAttackTime = 0;
  unit.lastDirection = { x: 0, y: 0 };
  gameContainer.appendChild(unit);
  units[team].push(unit);
  updateHealthBar(unit);
  if (['warrior', 'mage', 'archer', 'healer', 'tank', 'musketman'].includes(type)) {
    updateWeaponPosition(unit);
  }
  unit.addEventListener('mouseover', () => showStats(unit));
  unit.addEventListener('mouseout', hideStats);
}

function deleteUnit(unit) {
  const team = unit.classList.contains('blue') ? 'blue' : unit.classList.contains('red') ? 'red' : 'purple';
  const index = units[team].indexOf(unit);
  if (index > -1) {
    units[team].splice(index, 1);
  }
  gameContainer.removeChild(unit);
}

function showStats(unit) {
  const statsPanel = document.getElementById('stats-panel');
  statsPanel.innerHTML = `
    <h3>${unit.className.split(' ')[1].charAt(0).toUpperCase() + unit.className.split(' ')[1].slice(1)}</h3>
    <p>Health: ${unit.health}/${unit.maxHealth}</p>
    <p>Damage: ${unit.damage}</p>
    <p>Speed: ${unit.speed}</p>
    <p>Range: ${unit.range}</p>
    ${unit.healPower ? `<p>Heal Power: ${unit.healPower}</p>` : ''}
    <p>Team: ${unit.team}</p>
    <p>Type: ${unit.type === 'M' ? 'Melee' : unit.type === 'R' ? 'Ranged' : 'Support'}</p>
    ${unit.weapon ? `<p>Weapon: ${unit.weapon}</p>` : ''}
    ${unit.shield ? `<p>Shield: ${unit.shield}</p>` : ''}
    ${unit.attackCooldown ? `<p>Attack Cooldown: ${unit.attackCooldown / 1000}s</p>` : ''}
  `;
  statsPanel.style.display = 'block';
}

function hideStats() {
  document.getElementById('stats-panel').style.display = 'none';
}

function startBattle() {
  placementMode = false;
  deleteMode = false;
  selectionMode = false;
  updateModeDisplay();

  battleInterval = setInterval(() => {
    ['blue', 'red', 'purple'].forEach(team => {
      units[team].forEach(unit => {
        const enemies = ['blue', 'red', 'purple'].filter(t => t !== team).flatMap(t => units[t]);
        const allies = units[team];
        if (unit.health <= 0) return;
        
        if (unit.healPower && unit.projectiles > 0) {
          const woundedAlly = allies.find(ally => ally.health < ally.maxHealth);
          if (woundedAlly) {
            heal(unit, woundedAlly);
          }
        } else {
          const nearestEnemy = findNearestUnit(unit, enemies);
          if (nearestEnemy) {
            if (distance(unit, nearestEnemy) <= unit.range) {
              attack(unit, nearestEnemy);
            } else {
              moveTowards(unit, nearestEnemy);
            }
          }
        }
      });
    });

    if (checkBattleEnd()) {
      endBattle();
    }
  }, 50);
}

function checkBattleEnd() {
  const activeteams = ['blue', 'red', 'purple'].filter(team => units[team].length > 0);
  return activeteams.length <= 1;
}

function endBattle() {
  clearInterval(battleInterval);
  const winner = ['blue', 'red', 'purple'].find(team => units[team].length > 0) || 'No team';
  alert(`${winner.charAt(0).toUpperCase() + winner.slice(1)} wins!`);
  
  ['blue', 'red', 'purple'].forEach(team => {
    units[team].forEach(unit => gameContainer.removeChild(unit));
    units[team] = [];
  });
  placementMode = true;
  deleteMode = false;
  selectionMode = false;
  updateModeDisplay();
}

function findNearestUnit(unit, targets) {
  return targets.reduce((nearest, target) => 
    !nearest || distance(unit, target) < distance(unit, nearest) ? target : nearest
  , null);
}

function distance(unit1, unit2) {
  const dx = unit1.offsetLeft - unit2.offsetLeft;
  const dy = unit1.offsetTop - unit2.offsetTop;
  return Math.sqrt(dx * dx + dy * dy);
}


function move(unit, dx, dy) {
  const newX = unit.offsetLeft + dx;
  const newY = unit.offsetTop + dy;
  
  const containerRect = gameContainer.getBoundingClientRect();
  const unitRect = unit.getBoundingClientRect();
  
  const minX = 0;
  const minY = 0;
  const maxX = containerRect.width - unitRect.width;
  const maxY = containerRect.height - unitRect.height;
  
  unit.style.left = `${Math.max(minX, Math.min(maxX, newX))}px`;
  unit.style.top = `${Math.max(minY, Math.min(maxY, newY))}px`;

  if (['warrior', 'mage', 'archer', 'healer', 'tank', 'musketman'].includes(unit.className.split(' ')[1])) {
    updateWeaponPosition(unit);
  }
}

function moveTowards(unit, target) {
  const speed = unit.speed * (battleSpeed / 10);
  const angle = Math.atan2(target.offsetTop - unit.offsetTop, target.offsetLeft - unit.offsetLeft);
  const dx = Math.cos(angle) * speed;
  const dy = Math.sin(angle) * speed;
  
  move(unit, dx, dy);
  
  if (dx !== 0 || dy !== 0) {
    unit.lastDirection = { x: dx, y: dy };
  }
}

function updateWeaponPosition(unit) {
  let weapon, shield;
  const unitType = unit.className.split(' ')[1];
  if (unitType === 'warrior') {
    weapon = unit.querySelector('.wooden-sword');
  } else if (unitType === 'mage') {
    weapon = unit.querySelector('.wooden-staff');
  } else if (unitType === 'archer') {
    weapon = unit.querySelector('.bow');
  } else if (unitType === 'healer') {
    weapon = unit.querySelector('.healing-staff');
  } else if (unitType === 'tank') {
    weapon = unit.querySelector('.iron-sword');
    shield = unit.querySelector('.iron-shield');
  } else if (unitType === 'musketman') {
    weapon = unit.querySelector('.musket');
  }

  if (weapon) {
    const angle = Math.atan2(unit.lastDirection.y, unit.lastDirection.x);
    const radius = 20;
    
    const weaponX = Math.cos(angle) * radius;
    const weaponY = Math.sin(angle) * radius;
    
    weapon.style.transform = `translate(${weaponX}px, ${weaponY}px) rotate(${angle}rad)`;
    
    if (shield) {
      const shieldX = Math.cos(angle + Math.PI) * radius;
      const shieldY = Math.sin(angle + Math.PI) * radius;
      shield.style.transform = `translate(${shieldX}px, ${shieldY}px) rotate(${angle}rad)`;
    }
  }
}

function attack(attacker, defender) {
  const now = Date.now();
  if (attacker.attackCooldown && now - attacker.lastAttackTime < attacker.attackCooldown) {
    return;
  }

  if (attacker.isRanged && attacker.projectiles > 0) {
    fireProjectile(attacker, defender, getProjectileClass(attacker), () => {
      applyDamage(attacker, defender);
    });
    attacker.projectiles--;
    rechargeProjectiles(attacker);
    animateAttack(attacker);
  } else if (!attacker.isRanged) {
    applyDamage(attacker, defender);
    animateAttack(attacker);
  }

  attacker.lastAttackTime = now;
}

function getProjectileClass(unit) {
  const unitType = unit.className.split(' ')[1];
  switch (unitType) {
    case 'mage':
      return 'mage-projectile';
    case 'musketman':
      return 'musket-projectile';
    default:
      return 'attack-projectile';
  }
}

function animateAttack(unit) {
  const unitType = unit.className.split(' ')[1];
  unit.classList.add('attacking');
  setTimeout(() => {
    unit.classList.remove('attacking');
  }, 200);
}

function heal(healer, target) {
  if (Date.now() - healer.lastHealTime < 5000) return;
  
  fireProjectile(healer, target, 'heal-projectile', () => {
    target.health = Math.min(target.health + healer.healPower, target.maxHealth);
    updateHealthBar(target);
  });
  
  healer.projectiles--;
  if (healer.projectiles === 0) {
    healer.lastHealTime = Date.now();
    setTimeout(() => {
      healer.projectiles = 3;
    }, 5000);
  }
}

function fireProjectile(from, to, className, onHit) {
  const projectile = document.createElement('div');
  projectile.className = `projectile ${className}`;
  projectile.style.left = `${from.offsetLeft + 20}px`;
  projectile.style.top = `${from.offsetTop + 20}px`;
  gameContainer.appendChild(projectile);

  setTimeout(() => {
    projectile.style.left = `${to.offsetLeft + 20}px`;
    projectile.style.top = `${to.offsetTop + 20}px`;
  }, 50);

  setTimeout(() => {
    gameContainer.removeChild(projectile);
    onHit();
  }, 500);
}

function applyDamage(attacker, defender) {
  defender.health -= attacker.damage;
  updateHealthBar(defender);
  if (defender.health <= 0) {
    gameContainer.removeChild(defender);
    const index = units[defender.team].indexOf(defender);
    units[defender.team].splice(index, 1);
  }
}

function rechargeProjectiles(unit) {
  setTimeout(() => {
    unit.projectiles = Math.min(unit.projectiles + 1, 2);
  }, 2000);
}

function updateHealthBar(unit) {
  const healthBar = unit.querySelector('.health-bar');
  const healthPercentage = (unit.health / unit.maxHealth) * 100;
  healthBar.style.width = `${healthPercentage}%`;
}

function updateSpeed() {
  battleSpeed = document.getElementById('speed-slider').value;
}

function applyFormation(formationType) {
  if (selectedUnits.length === 0) return;

  const centerX = selectedUnits.reduce((sum, unit) => sum + unit.offsetLeft, 0) / selectedUnits.length;
  const centerY = selectedUnits.reduce((sum, unit) => sum + unit.offsetTop, 0) / selectedUnits.length;

  let formationPositions = [];

  switch (formationType) {
    case 'line':
      formationPositions = getLineFormation(selectedUnits.length, centerX, centerY);
      break;
    case 'column':
      formationPositions = getColumnFormation(selectedUnits.length, centerX, centerY);
      break;
    case 'wedge':
      formationPositions = getWedgeFormation(selectedUnits.length, centerX, centerY);
      break;
    case 'square':
      formationPositions = getSquareFormation(selectedUnits.length, centerX, centerY);
      break;
    case 'circle':
      formationPositions = getCircleFormation(selectedUnits.length, centerX, centerY);
      break;
  }

  selectedUnits.forEach((unit, index) => {
    const newPosition = formationPositions[index];
    unit.style.left = `${newPosition.x}px`;
    unit.style.top = `${newPosition.y}px`;
    updateWeaponPosition(unit);
  });
}

function getLineFormation(unitCount, centerX, centerY) {
  const spacing = 50;
  const totalWidth = (unitCount - 1) * spacing;
  const startX = centerX - totalWidth / 2;
  return Array.from({ length: unitCount }, (_, i) => ({
    x: startX + i * spacing,
    y: centerY
  }));
}

function getColumnFormation(unitCount, centerX, centerY) {
  const spacing = 50;
  const totalHeight = (unitCount - 1) *
  spacing;
  const startY = centerY - totalHeight / 2;
  return Array.from({ length: unitCount }, (_, i) => ({
    x: centerX,
    y: startY + i * spacing
  }));
}

function getWedgeFormation(unitCount, centerX, centerY) {
  const spacing = 50;
  const rows = Math.ceil(Math.sqrt(unitCount * 2));
  let positions = [];
  let currentY = centerY;
  let unitsInRow = 1;

  for (let i = 0; i < unitCount; i++) {
    if (positions.length === unitsInRow) {
      currentY += spacing;
      unitsInRow++;
      positions = [];
    }
    const rowWidth = (unitsInRow - 1) * spacing;
    const x = centerX - rowWidth / 2 + positions.length * spacing;
    positions.push({ x, y: currentY });
  }

  return positions;
}

function getSquareFormation(unitCount, centerX, centerY) {
  const spacing = 50;
  const sideLength = Math.ceil(Math.sqrt(unitCount));
  const totalWidth = (sideLength - 1) * spacing;
  const startX = centerX - totalWidth / 2;
  const startY = centerY - totalWidth / 2;

  let positions = [];
  for (let i = 0; i < sideLength; i++) {
    for (let j = 0; j < sideLength; j++) {
      if (positions.length < unitCount) {
        positions.push({
          x: startX + j * spacing,
          y: startY + i * spacing
        });
      }
    }
  }
  return positions;
}

function getCircleFormation(unitCount, centerX, centerY) {
  const radius = unitCount * 10;
  return Array.from({ length: unitCount }, (_, i) => {
    const angle = (i / unitCount) * 2 * Math.PI;
    return {
      x: centerX + radius * Math.cos(angle),
      y: centerY + radius * Math.sin(angle)
    };
  });
}

updateModeDisplay();

const updateMessage = document.getElementById('update-message');
updateMessage.style.display = 'block';
setTimeout(() => {
  updateMessage.style.display = 'none';
}, 3000);

</script>
</body>
</html>